/**
 * Higher order component with touching feature
 * @function withTouch
 * @param {function} Component - A component constructor
 * @returns {function} - Wrapped component
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _breact = require('breact');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _asobj = require('asobj');

var _enums = require('./enums');

var _new_hammer = require('./helpers/new_hammer');

var _new_hammer2 = _interopRequireDefault(_new_hammer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var propTypes = {
  /** Handler for "tap" event */
  onTap: _react.PropTypes.func,
  /** Handler for "doubletap" event */
  onDoubleTap: _react.PropTypes.func,
  /** Handler for "pan" event */
  onPan: _react.PropTypes.func,
  /** Handler for "panstart" event */
  onPanStart: _react.PropTypes.func,
  /** Handler for "panmove" event */
  onPanMove: _react.PropTypes.func,
  /** Handler for "panend" event */
  onPanEnd: _react.PropTypes.func,
  /** Handler for "pancancel" event */
  onPanCancel: _react.PropTypes.func,
  /** Handler for "swipe" event */
  onSwipe: _react.PropTypes.func,
  /** Handler for "press" event */
  onPress: _react.PropTypes.func,
  /** Handler for "pressup" event */
  onPressUp: _react.PropTypes.func,
  /** Handler for "pinch" event */
  onPinch: _react.PropTypes.func,
  /** Handler for "pinchstart" event */
  onPinchStart: _react.PropTypes.func,
  /** Handler for "pinchmove" event */
  onPinchMove: _react.PropTypes.func,
  /** Handler for "pinchend" event */
  onPinchEnd: _react.PropTypes.func,
  /** Handler for "pinchcancel" event */
  onPinchCancel: _react.PropTypes.func,
  /** Handler for "rotate" event */
  onRotate: _react.PropTypes.func,
  /** Handler for "rotatestart" event */
  onRotateStart: _react.PropTypes.func,
  /** Handler for "rotatemove" event */
  onRotateMove: _react.PropTypes.func,
  /** Handler for "rotateend" event */
  onRotateEnd: _react.PropTypes.func,
  /** Handler for "rotatecancel" event */
  onRotateCancel: _react.PropTypes.func,
  /** Options for touch */
  touchOptions: _react.PropTypes.object,
  /** Pixcel for pan threshold */
  panThreshold: _react.PropTypes.number,
  /** Direction for pan */
  panDirection: _react.PropTypes.oneOf(_enums.directions),
  /** Direction for swipe */
  swipeDirection: _react.PropTypes.oneOf(_enums.directions)
};

function createTouchHammer(node, props, getData) {
  if (!node) {
    return;
  }
  var hammer = (0, _new_hammer2.default)(node);
  if (props.touchOptions) {
    hammer.set(props.touchOptions);
  }
  (0, _keys2.default)(propTypes).filter(function (key) {
    return !!props[key];
  }).forEach(function (key) {
    if (/^on/.test(key)) {
      (function () {
        var event = key.replace(/^on/, '').toLowerCase();
        var handler = props[key];
        hammer.on(event, function (e) {
          e.data = getData(); // Set touching data.
          handler(e);
        });
      })();
    }
    if (/Direction$/.test(key)) {
      var gesture = key.replace(/Direction$/, '');
      hammer.get(gesture).set({ direction: hammer.Hammer['DIRECTION_' + props[key]] });
    }
    if (/Threshold$/.test(key)) {
      var threshold = key.replace(/Threshold$/, '');
      hammer.get(threshold).set({ threshold: props[key] });
    }
  });
  return hammer;
}

function destroyTouchHammer(hammer) {
  if (!hammer) {
    return;
  }
  hammer.stop();
  hammer.destroy();
}

function supportsTouch(props) {
  var touchableKey = (0, _keys2.default)(propTypes);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(props)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var hit = !!~touchableKey.indexOf(key);
      if (hit) {
        return true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return false;
}

/** @lends withTouch */
function withTouch(Component) {
  var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var getTouchData = config.getTouchData;

  var spec = (0, _assign2.default)({
    displayName: 'withTouch',

    propTypes: propTypes,

    render: function render() {
      var s = this;
      var props = s.props;

      var wrappedProps = (0, _asobj.clone)(props, {
        without: (0, _keys2.default)(propTypes || {})
      });
      wrappedProps.hasTouch = !!props.onTap;
      var children = _react2.default.Children.toArray(props.children);
      return _react2.default.createElement.apply(_react2.default, [Component, wrappedProps].concat((0, _toConsumableArray3.default)(children)));
    },
    componentDidMount: function componentDidMount() {
      var s = this;
      var touchable = supportsTouch(s.props);
      var getData = function getData() {
        return s.getTouchData ? s.getTouchData() : undefined;
      };
      if (touchable) {
        s.touchHammer = createTouchHammer(_reactDom2.default.findDOMNode(s), s.props, getData);
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      var s = this;
      var hammer = s.touchHammer;
      if (hammer) {
        destroyTouchHammer(hammer);
      }
      delete s.touchHammer;
    }
  }, { getTouchData: getTouchData });
  return (0, _breact.wrap)(Component, spec);
}

exports.default = withTouch;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndpdGhfdG91Y2guanN4Il0sIm5hbWVzIjpbInByb3BUeXBlcyIsIm9uVGFwIiwiZnVuYyIsIm9uRG91YmxlVGFwIiwib25QYW4iLCJvblBhblN0YXJ0Iiwib25QYW5Nb3ZlIiwib25QYW5FbmQiLCJvblBhbkNhbmNlbCIsIm9uU3dpcGUiLCJvblByZXNzIiwib25QcmVzc1VwIiwib25QaW5jaCIsIm9uUGluY2hTdGFydCIsIm9uUGluY2hNb3ZlIiwib25QaW5jaEVuZCIsIm9uUGluY2hDYW5jZWwiLCJvblJvdGF0ZSIsIm9uUm90YXRlU3RhcnQiLCJvblJvdGF0ZU1vdmUiLCJvblJvdGF0ZUVuZCIsIm9uUm90YXRlQ2FuY2VsIiwidG91Y2hPcHRpb25zIiwib2JqZWN0IiwicGFuVGhyZXNob2xkIiwibnVtYmVyIiwicGFuRGlyZWN0aW9uIiwib25lT2YiLCJzd2lwZURpcmVjdGlvbiIsImNyZWF0ZVRvdWNoSGFtbWVyIiwibm9kZSIsInByb3BzIiwiZ2V0RGF0YSIsImhhbW1lciIsInNldCIsImZpbHRlciIsImtleSIsImZvckVhY2giLCJ0ZXN0IiwiZXZlbnQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJoYW5kbGVyIiwib24iLCJlIiwiZGF0YSIsImdlc3R1cmUiLCJnZXQiLCJkaXJlY3Rpb24iLCJIYW1tZXIiLCJ0aHJlc2hvbGQiLCJkZXN0cm95VG91Y2hIYW1tZXIiLCJzdG9wIiwiZGVzdHJveSIsInN1cHBvcnRzVG91Y2giLCJ0b3VjaGFibGVLZXkiLCJoaXQiLCJpbmRleE9mIiwid2l0aFRvdWNoIiwiQ29tcG9uZW50IiwiY29uZmlnIiwiZ2V0VG91Y2hEYXRhIiwic3BlYyIsImRpc3BsYXlOYW1lIiwicmVuZGVyIiwicyIsIndyYXBwZWRQcm9wcyIsIndpdGhvdXQiLCJoYXNUb3VjaCIsImNoaWxkcmVuIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiY3JlYXRlRWxlbWVudCIsImNvbXBvbmVudERpZE1vdW50IiwidG91Y2hhYmxlIiwidW5kZWZp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Um9vdCI6ImxpYiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGlnaGVyIG9yZGVyIGNvbXBvbmVudCB3aXRoIHRvdWNoaW5nIGZlYXR1cmVcbiAqIEBmdW5jdGlvbiB3aXRoVG91Y2hcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENvbXBvbmVudCAtIEEgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gV3JhcHBlZCBjb21wb25lbnRcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7d3JhcH0gZnJvbSAnYnJlYWN0J1xuaW1wb3J0IFJlYWN0LCB7UHJvcFR5cGVzIGFzIHR5cGVzfSBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQge2Nsb25lfSBmcm9tICdhc29iaidcbmltcG9ydCB7ZGlyZWN0aW9uc30gZnJvbSAnLi9lbnVtcydcbmltcG9ydCBuZXdIYW1tZXIgZnJvbSAnLi9oZWxwZXJzL25ld19oYW1tZXInXG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgLyoqIEhhbmRsZXIgZm9yIFwidGFwXCIgZXZlbnQgKi9cbiAgb25UYXA6IHR5cGVzLmZ1bmMsXG4gIC8qKiBIYW5kbGVyIGZvciBcImRvdWJsZXRhcFwiIGV2ZW50ICovXG4gIG9uRG91YmxlVGFwOiB0eXBlcy5mdW5jLFxuICAvKiogSGFuZGxlciBmb3IgXCJwYW5cIiBldmVudCAqL1xuICBvblBhbjogdHlwZXMuZnVuYyxcbiAgLyoqIEhhbmRsZXIgZm9yIFwicGFuc3RhcnRcIiBldmVudCAqL1xuICBvblBhblN0YXJ0OiB0eXBlcy5mdW5jLFxuICAvKiogSGFuZGxlciBmb3IgXCJwYW5tb3ZlXCIgZXZlbnQgKi9cbiAgb25QYW5Nb3ZlOiB0eXBlcy5mdW5jLFxuICAvKiogSGFuZGxlciBmb3IgXCJwYW5lbmRcIiBldmVudCAqL1xuICBvblBhbkVuZDogdHlwZXMuZnVuYyxcbiAgLyoqIEhhbmRsZXIgZm9yIFwicGFuY2FuY2VsXCIgZXZlbnQgKi9cbiAgb25QYW5DYW5jZWw6IHR5cGVzLmZ1bmMsXG4gIC8qKiBIYW5kbGVyIGZvciBcInN3aXBlXCIgZXZlbnQgKi9cbiAgb25Td2lwZTogdHlwZXMuZnVuYyxcbiAgLyoqIEhhbmRsZXIgZm9yIFwicHJlc3NcIiBldmVudCAqL1xuICBvblByZXNzOiB0eXBlcy5mdW5jLFxuICAvKiogSGFuZGxlciBmb3IgXCJwcmVzc3VwXCIgZXZlbnQgKi9cbiAgb25QcmVzc1VwOiB0eXBlcy5mdW5jLFxuICAvKiogSGFuZGxlciBmb3IgXCJwaW5jaFwiIGV2ZW50ICovXG4gIG9uUGluY2g6IHR5cGVzLmZ1bmMsXG4gIC8qKiBIYW5kbGVyIGZvciBcInBpbmNoc3RhcnRcIiBldmVudCAqL1xuICBvblBpbmNoU3RhcnQ6IHR5cGVzLmZ1bmMsXG4gIC8qKiBIYW5kbGVyIGZvciBcInBpbmNobW92ZVwiIGV2ZW50ICovXG4gIG9uUGluY2hNb3ZlOiB0eXBlcy5mdW5jLFxuICAvKiogSGFuZGxlciBmb3IgXCJwaW5jaGVuZFwiIGV2ZW50ICovXG4gIG9uUGluY2hFbmQ6IHR5cGVzLmZ1bmMsXG4gIC8qKiBIYW5kbGVyIGZvciBcInBpbmNoY2FuY2VsXCIgZXZlbnQgKi9cbiAgb25QaW5jaENhbmNlbDogdHlwZXMuZnVuYyxcbiAgLyoqIEhhbmRsZXIgZm9yIFwicm90YXRlXCIgZXZlbnQgKi9cbiAgb25Sb3RhdGU6IHR5cGVzLmZ1bmMsXG4gIC8qKiBIYW5kbGVyIGZvciBcInJvdGF0ZXN0YXJ0XCIgZXZlbnQgKi9cbiAgb25Sb3RhdGVTdGFydDogdHlwZXMuZnVuYyxcbiAgLyoqIEhhbmRsZXIgZm9yIFwicm90YXRlbW92ZVwiIGV2ZW50ICovXG4gIG9uUm90YXRlTW92ZTogdHlwZXMuZnVuYyxcbiAgLyoqIEhhbmRsZXIgZm9yIFwicm90YXRlZW5kXCIgZXZlbnQgKi9cbiAgb25Sb3RhdGVFbmQ6IHR5cGVzLmZ1bmMsXG4gIC8qKiBIYW5kbGVyIGZvciBcInJvdGF0ZWNhbmNlbFwiIGV2ZW50ICovXG4gIG9uUm90YXRlQ2FuY2VsOiB0eXBlcy5mdW5jLFxuICAvKiogT3B0aW9ucyBmb3IgdG91Y2ggKi9cbiAgdG91Y2hPcHRpb25zOiB0eXBlcy5vYmplY3QsXG4gIC8qKiBQaXhjZWwgZm9yIHBhbiB0aHJlc2hvbGQgKi9cbiAgcGFuVGhyZXNob2xkOiB0eXBlcy5udW1iZXIsXG4gIC8qKiBEaXJlY3Rpb24gZm9yIHBhbiAqL1xuICBwYW5EaXJlY3Rpb246IHR5cGVzLm9uZU9mKGRpcmVjdGlvbnMpLFxuICAvKiogRGlyZWN0aW9uIGZvciBzd2lwZSAqL1xuICBzd2lwZURpcmVjdGlvbjogdHlwZXMub25lT2YoZGlyZWN0aW9ucylcbn1cblxuZnVuY3Rpb24gY3JlYXRlVG91Y2hIYW1tZXIgKG5vZGUsIHByb3BzLCBnZXREYXRhKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBoYW1tZXIgPSBuZXdIYW1tZXIobm9kZSlcbiAgaWYgKHByb3BzLnRvdWNoT3B0aW9ucykge1xuICAgIGhhbW1lci5zZXQocHJvcHMudG91Y2hPcHRpb25zKVxuICB9XG4gIE9iamVjdC5rZXlzKHByb3BUeXBlcylcbiAgICAuZmlsdGVyKChrZXkpID0+ICEhcHJvcHNbIGtleSBdKVxuICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICgvXm9uLy50ZXN0KGtleSkpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0ga2V5LnJlcGxhY2UoL15vbi8sICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxldCBoYW5kbGVyID0gcHJvcHNbIGtleSBdXG4gICAgICAgIGhhbW1lci5vbihldmVudCwgKGUpID0+IHtcbiAgICAgICAgICBlLmRhdGEgPSBnZXREYXRhKCkgLy8gU2V0IHRvdWNoaW5nIGRhdGEuXG4gICAgICAgICAgaGFuZGxlcihlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYgKC9EaXJlY3Rpb24kLy50ZXN0KGtleSkpIHtcbiAgICAgICAgbGV0IGdlc3R1cmUgPSBrZXkucmVwbGFjZSgvRGlyZWN0aW9uJC8sICcnKVxuICAgICAgICBoYW1tZXIuZ2V0KGdlc3R1cmUpLnNldCh7IGRpcmVjdGlvbjogaGFtbWVyLkhhbW1lclsgJ0RJUkVDVElPTl8nICsgcHJvcHNbIGtleSBdIF0gfSlcbiAgICAgIH1cbiAgICAgIGlmICgvVGhyZXNob2xkJC8udGVzdChrZXkpKSB7XG4gICAgICAgIGxldCB0aHJlc2hvbGQgPSBrZXkucmVwbGFjZSgvVGhyZXNob2xkJC8sICcnKVxuICAgICAgICBoYW1tZXIuZ2V0KHRocmVzaG9sZCkuc2V0KHsgdGhyZXNob2xkOiBwcm9wc1sga2V5IF0gfSlcbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gaGFtbWVyXG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lUb3VjaEhhbW1lciAoaGFtbWVyKSB7XG4gIGlmICghaGFtbWVyKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaGFtbWVyLnN0b3AoKVxuICBoYW1tZXIuZGVzdHJveSgpXG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzVG91Y2ggKHByb3BzKSB7XG4gIGxldCB0b3VjaGFibGVLZXkgPSBPYmplY3Qua2V5cyhwcm9wVHlwZXMpXG4gIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhwcm9wcykpIHtcbiAgICBsZXQgaGl0ID0gISF+dG91Y2hhYmxlS2V5LmluZGV4T2Yoa2V5KVxuICAgIGlmIChoaXQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiogQGxlbmRzIHdpdGhUb3VjaCAqL1xuZnVuY3Rpb24gd2l0aFRvdWNoIChDb21wb25lbnQsIGNvbmZpZyA9IHt9KSB7XG4gIGxldCB7IGdldFRvdWNoRGF0YSB9ID0gY29uZmlnXG4gIGxldCBzcGVjID0gT2JqZWN0LmFzc2lnbih7XG4gICAgZGlzcGxheU5hbWU6ICd3aXRoVG91Y2gnLFxuXG4gICAgcHJvcFR5cGVzLFxuXG4gICAgcmVuZGVyICgpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgICBsZXQgeyBwcm9wcyB9ID0gc1xuICAgICAgbGV0IHdyYXBwZWRQcm9wcyA9IGNsb25lKHByb3BzLCB7XG4gICAgICAgIHdpdGhvdXQ6IE9iamVjdC5rZXlzKHByb3BUeXBlcyB8fCB7fSlcbiAgICAgIH0pXG4gICAgICB3cmFwcGVkUHJvcHMuaGFzVG91Y2ggPSAhIShwcm9wcy5vblRhcClcbiAgICAgIGxldCBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkocHJvcHMuY2hpbGRyZW4pXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHdyYXBwZWRQcm9wcywgLi4uY2hpbGRyZW4pXG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgICBsZXQgdG91Y2hhYmxlID0gc3VwcG9ydHNUb3VjaChzLnByb3BzKVxuICAgICAgbGV0IGdldERhdGEgPSAoKSA9PiBzLmdldFRvdWNoRGF0YSA/IHMuZ2V0VG91Y2hEYXRhKCkgOiB1bmRlZmluZWRcbiAgICAgIGlmICh0b3VjaGFibGUpIHtcbiAgICAgICAgcy50b3VjaEhhbW1lciA9IGNyZWF0ZVRvdWNoSGFtbWVyKFJlYWN0RE9NLmZpbmRET01Ob2RlKHMpLCBzLnByb3BzLCBnZXREYXRhKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgICBjb25zdCBzID0gdGhpc1xuICAgICAgbGV0IGhhbW1lciA9IHMudG91Y2hIYW1tZXJcbiAgICAgIGlmIChoYW1tZXIpIHtcbiAgICAgICAgZGVzdHJveVRvdWNoSGFtbWVyKGhhbW1lcilcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBzLnRvdWNoSGFtbWVyXG4gICAgfVxuICB9LCB7IGdldFRvdWNoRGF0YSB9KVxuICByZXR1cm4gd3JhcChDb21wb25lbnQsIHNwZWMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhUb3VjaFxuIl19